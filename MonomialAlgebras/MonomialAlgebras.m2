
newPackage(
	"MonomialAlgebras",
    	Version => "0.1", 
    	Date => "Feb 27, 2011",
    	Authors => {
                  },
    	Headline => "Monomial algebras",
	CacheExampleOutput => false,
	AuxiliaryFiles => false,
    	DebuggingMode => true
        )

-- For information see documentation key "MonomialAlgebras" below.

export({decomposeMonomialCurve,decomposeMonomialAlgebra,homogenizeSemigroup,adjoinPurePowers})


decomposeMonomialCurve=method()
decomposeMonomialCurve(List):= A -> (
   kk:=QQ;
   x:=symbol x;
   s:=symbol s;
   t:=symbol t;
   if not gcd A ==1 then print "WARNING: exponents not relatively prime";
   n := #A;
   d := max A;
   deglist := prepend({0,d}, for i from 0 to n-1 list {A_i, d-A_i});
   S := kk[x_0..x_n, Degrees =>deglist];
   P := kk[s,t, Degrees =>{{1,0}, {0,1}}];
   maplist := deglist/(D->s^(D_1)*t^(D_0));
   I := ker map(P,S,maplist);
   N := S^1/(ideal(x_0,x_n)+I);
   bN := basis N;
   L := partition(p -> (first p)%d, last degrees bN);
   --replace each value by itself normalized then divided by d, 
   --with a twist to show the amount of normalization.
   L1 := applyValues(L,LL -> (
	  min1 := min(LL/first);
	  min2 := min(LL/last);
	  LL1 := {LL/(p->{(first p - min1)//d, (last p - min2)//d}),  (min1+min2)//d}
     ));
   a:=local a;
   b:=local b;
   T := kk[a,b];
   --Now make ideals in T by grouping the degrees in genDegs by congruence class.
  applyValues(L1, LL->( 
     (ideal apply(first LL, m->T_0^(first m)*T_1^(last m)))*(T^{-last LL}))
	  )
)

decomposeMonomialAlgebra=method()
decomposeMonomialAlgebra(List):= A -> (
--A should be a list of elements of NN^(m-1), all of total degree <=d, (thought of
--as homogeneous elements of degree d in NN^m.
B := adjoinPurePowers homogenizeSemigroup A;
d := sum B_0;
m := #B_0;
n := #B;
   kk:=QQ;
   x:=symbol x;
   s:=symbol s;
   t:=symbol t;
S := kk[x_0..x_(n-1), Degrees => B];
C :=  apply(m, i-> apply(m, j -> if(j == i) then d else 0));  -- pure powers
P := kk[s_0..s_(m-1), Degrees => C];
I := monomialAlgebraIdeal(S, B);
N := S^1/(ideal(x_0..x_(m-1))+I);
bN := basis N;
L := partition(p -> p/(i -> i%d), last degrees bN);
--replace each value by itself normalized then divided by d, 
--with a twist to show the amount of normalization.
L1 := applyValues(L,LL -> (
	  degLL0 := (sum LL_0)//d;
--	  degLL = (min(LL/sum))//d;
	  LL1 := LL / (l -> (apply(l - LL_0,j->j//d)));
	  mins := apply(#LL_0, i -> min apply(LL1, l -> l#i));
	  {LL1 / (l -> l-mins), degLL0}
     ));
a := local a;
T := kk[a_0..a_(m-1)];
--Now make ideals in T by grouping the degrees in genDegs by congruence class.
applyValues(L1, LL->( 
	  LLf := first LL;
     (ideal apply(LLf, mm->product(apply(#mm, i-> T_i^(mm_i)))))*(T^{-last LL}))
	  )
)
homogenizeSemigroup=method()
homogenizeSemigroup(List):= A ->(
     d := max (A/sum);
     A/(a->append(a, d-sum a))
     )

adjoinPurePowers=method()
adjoinPurePowers(List) := B -> (
     d :=  sum B_0;
     m := #(B_0);
     unique(apply(m, i-> apply(m, j -> if(j == i) then d else 0)) | B)
     )
monomialAlgebraIdeal=method()
monomialAlgebraIdeal(PolynomialRing,List) := (R,B) -> (
     --R should be a standard poly ring with at least as many vars as #A.
     --#A is a list of lists of ZZ, all of the same length m-1.
     --forms the ideal in R corresponding defining the monomial algebra
     --generated by monomials x^(B_i), where B is the list of homogenizations
     -- of the lists in A.
     m := #B_0;
     nR := numgens R;
     if nR < #B then error "not enough variables in R";
     t := local t;
     k:= coefficientRing R;
     T := k[t_0..t_(m-1)];
     targ :=  apply(B, b -> product(apply (#b, i-> t_i^(b_i))));
     Targ := targ |splice {nR-#B:0_T};
     ker map(T,R,Targ)
     )



------------------------------------------------------------------------------------------



beginDocumentation()

doc ///
  Key
    MonomialAlgebras
  Headline
    Monomial Algebras.
  Description
    Text
      {\bf What's new:}

      {\it Version 0.01:}

      First version.

      {\bf Overview:}
      
      Consider a semigroup A in \mathbb{N}^m and a subsemigroup B \subset A.
      such that rank(G(B))=rank(G(A)).
      
      The corresponding monomial algebra K[A] is decomposed as a direct sum of ideals in K[B]. In
      
      Le Tuan Hoa, Juergen Stueckrad: Castelnuovo–Mumford regularity of simplicial toric rings.
      
      it is shown that this decomposition exists in the case that K[B] is isomorphic to a polynomial ring
      and is the Noether normalization of K[A] (the simplicial case).
      
      {\bf Setup:}

      This package requires Macaulay2 version 1.4 or newer.

      Install this @TO Package@ by doing

      @TO installPackage@("MonomialAlgebras")

      {\bf Examples:}

      {\bf Curves:}

      @TO "Curve Example 1"@

      
///


doc ///
  Key
    decomposeMonomialCurve
    (decomposeMonomialCurve,List)
  Headline
    Decomposition for the monomial curve.
  Usage
    decomposeMonomialCurve(A)
  Inputs
    A:List
        containing generators of A
  Outputs
    :List
  Description
   Text
     The list A is expected to contain dehomogenized generators of a semigroup.
     This function transforms A into a homogeneous semigroup containing
     powers of the variables. The corresponding monomial algebra
     is decomposed as a direct sum of ideals in its Noether normalization.

     Here we compute the decomposition for a curve parametrized by the monomials t^a with a \in A
     and B given by the first and the last element of A.

   Example
     A = {1,3,4};
     decomposeMonomialCurve A
   Text

   Example
     for d from 4 to 10 do (A = {1,d-1,d};print(A,decomposeMonomialCurve A));
///



doc ///
  Key
    decomposeMonomialAlgebra
    (decomposeMonomialAlgebra,List)
  Headline
    Decomposition for the monomial curve.
  Usage
    decomposeMonomialAlgebra(A)
  Inputs
    A:List
        containing generators of A
  Outputs
    :List
  Description
   Text
     The list A contains dehomogenized generators of a semigroup.
     This function transforms A into a homogeneous semigroup containing
     powers of the variables. The corresponding monomial algebra
     is decomposed as a direct sum of ideals in its Noether normalization.
     
   Example
      A = {{1,2},{3,0},{0,4},{0,5}}
      adjoinPurePowers homogenizeSemigroup A
      decomposeMonomialAlgebra (A)
///


doc ///
  Key
    "Curve Example 1"
  Description
   Text
   
    Consider
   
   Example
     A = {1,3,4};
     decomposeMonomialCurve A
///




{*
uninstallPackage("MonomialAlgebras")
installPackage("MonomialAlgebras",RerunExamples=>true);
installPackage("MonomialAlgebras");
*}
