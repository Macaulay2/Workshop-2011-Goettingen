
newPackage(
	"MonomialAlgebras2",
    	Version => "0.1", 
    	Date => "Feb 27, 2011",
    	Authors => {
                  },
    	Headline => "Monomial algebras",
	CacheExampleOutput => false,
	AuxiliaryFiles => false,
    	DebuggingMode => true
        )

-- For information see documentation key "MonomialAlgebras" below.

export({decomposeMonomialCurve,decomposeMonomialAlgebra,homogenizeSemigroup,adjoinPurePowers})


decomposeMonomialCurve=method()
decomposeMonomialCurve(List):= A -> (
   kk:=QQ;
   x:=symbol x;
   s:=symbol s;
   t:=symbol t;
   if not gcd A ==1 then print "WARNING: exponents not relatively prime";
   n := #A;
   d := max A;
   deglist := prepend({0,d}, for i from 0 to n-1 list {A_i, d-A_i});
   S := kk[x_0..x_n, Degrees =>deglist];
   P := kk[s,t, Degrees =>{{1,0}, {0,1}}];
   maplist := deglist/(D->s^(D_1)*t^(D_0));
   I := ker map(P,S,maplist);
   N := S^1/(ideal(x_0,x_n)+I);
   bN := basis N;
   L := partition(p -> (first p)%d, last degrees bN);
   --replace each value by itself normalized then divided by d, 
   --with a twist to show the amount of normalization.
   L1 := applyValues(L,LL -> (
	  min1 := min(LL/first);
	  min2 := min(LL/last);
	  LL1 := {LL/(p->{(first p - min1)//d, (last p - min2)//d}),  (min1+min2)//d}
     ));
   a:=local a;
   b:=local b;
   T := kk[a,b];
   --Now make ideals in T by grouping the degrees in genDegs by congruence class.
  applyValues(L1, LL->( 
     (ideal apply(first LL, m->T_0^(first m)*T_1^(last m)))*(T^{-last LL}))
	  )
)

-- f=map(QQ[y],QQ[x], {y^2})
{*
B = {{1,2},{3,0},{0,4},{0,5}}
C = {{1,2},{0,5}}
S = kk[x_0..x_3, Degrees=> B]
P = kk[y_0,y_1, Degrees=> C]
f = map(S,P,{x_0,x_3})
monomialAlgebraIdeal S
monomialAlgebraIdeal P
decomposeMonomialAlgebra f

for d from 4 to 10 do(
  f= map(kk[x_0..x_3, 
     Degrees=>{{d,0},{d-1,1},{1,d-1},{0,d}}], kk[x_0,x_3,Degrees=>{{d,0},{0,d}}]);
print decomposeMonomialAlgebra f)

*}


{*
makePositive = method()
makePositive1(List, List) := (C,v) ->(
     c = sum C;
     while #select(1,join toSequence v, i-> i<0)>0 do v = v/(v1 -> v1+c);
     vmin = for i from 0 to #v_0-1 list min apply (v, v1->v1_i);
      while #(c0 = select(1, C, C1->C1 < vmin))>0 do(
     if #c0 !=0 then v = apply(v, v1-> v1-c0_0);
     vmin = vmin -c_0);
     v
)
makePositive(List, List) := (C,v) ->(
     vm = transpose matrix v;
     Cm = transpose matrix C;
     coef = vm//Cm;
     mins = for i from 0 to numrows coef -1 list 
            min (entries coef^{i})#0;
     Mins = transpose matrix{mins} * matrix{{numcols vm:1}};
     coef1 = coef-Mins;
     for i from 0 to numcols vm -1 list entries((Cm*coef1)_i)
)
C = {{1,2},{0,5}}     
V = {{-1,3},{1,-3}, {1,7}}
makePositive(C,V)
coef
coef1-coef
Cm*coef
Cm*coef1
*}
decomposeMonomialAlgebra=method()
decomposeMonomialAlgebra(RingMap):= f -> (
S:=target f;
P:=source f;
p := numgens P;
n := numgens S;
B = degrees S;
C:=degrees P;
c := sum C;
m := #B_0;
I := monomialAlgebraIdeal S;
N = S^1/(f(ideal vars P)+I);
bN = last degrees basis N;
print bN;
--B1:=transpose matrix B;
C1 =gens gb transpose matrix C;
L := partition(j->(transpose matrix {j})%C1,bN);
L1 := applyPairs(L,(k,v) -> (k,apply(v, v1->
	       (entries transpose((transpose matrix{v1})-k))#0)));
L2 :=applyValues (L1, V->(  
     vm = transpose matrix V;
     Cm = transpose matrix C;
     coef = vm//Cm;
     mins = for i from 0 to numrows coef -1 list 
            min (entries coef^{i})#0;
     Mins = transpose matrix{mins} * matrix{{numcols vm:1}};
     coef1 = coef-Mins;
     {ideal(apply(numcols coef1, v->product(apply(p, j->P_j^(coef1_v_j))))), -mins}
));
print L;
print L1;
print L2;
FS = frac S;
Ff = map(FS,S)*f;
applyPairs(L2, (k,v) -> 
(k, {v_0, (product(apply(#entries k, 
		j->FS_j^(k_(j,0))))*
      product apply(p, j->(Ff(P_j))^(v_1_j)))}))
--applyPairs(L2, (k,v) -> 
-- (k, {v_0, product(apply(#entries k, j->FS_j^(k_(j,0))))}))
)
d=4
  f= map(kk[x_0..x_3, 
     Degrees=>{{d,0},{d-1,1},{1,d-1},{0,d}}], kk[x_0,x_3,Degrees=>{{d,0},{0,d}}])
decomposeMonomialAlgebra f
f((source f)_0)
mins
C1



homogenizeSemigroup=method()
homogenizeSemigroup(List):= A ->(
     d := max (A/sum);
     A/(a->append(a, d-sum a))
     )

adjoinPurePowers=method()
adjoinPurePowers(List) := B -> (
     d :=  sum B_0;
     m := #(B_0);
     unique(apply(m, i-> apply(m, j -> if(j == i) then d else 0)) | B)
     )
     
monomialAlgebraIdeal=method()
monomialAlgebraIdeal(PolynomialRing) := (R) -> (
     --R should be a multigraded poly ring
     --forms the ideal in R corresponding to the degree monoid algebra
     --generated by monomials x^(B_i), where B is the list of degrees of
     --the variables of R
     B:=degrees R;
     m := #B_0;
     t := local t;
     k:= coefficientRing R;
     T := k[t_0..t_(m-1)];
     targ :=  apply(B, b -> product(apply (#b, i-> t_i^(b_i))));
     ker map(T,R,targ)
     )



------------------------------------------------------------------------------------------



beginDocumentation()

doc ///
  Key
    MonomialAlgebras2
  Headline
    Monomial Algebras.
  Description
    Text
      {\bf What's new:}

      {\it Version 0.01:}

      First version.

      {\bf Overview:}
      
      Consider a semigroup A in \mathbb{N}^m and a subsemigroup B \subset A.
      such that rank(G(B))=rank(G(A)).
      
      The corresponding monomial algebra K[A] is decomposed as a direct sum of ideals in K[B]. In
      
      Le Tuan Hoa, Juergen Stueckrad: Castelnuovo–Mumford regularity of simplicial toric rings.
      
      it is shown that this decomposition exists in the case that K[B] is isomorphic to a polynomial ring
      and is the Noether normalization of K[A] (the simplicial case).
      
      {\bf Setup:}

      This package requires Macaulay2 version 1.4 or newer.

      Install this @TO Package@ by doing

      @TO installPackage@("MonomialAlgebras")

      {\bf Examples:}

      {\bf Curves:}

      @TO "Curve Example 1"@

      
///


doc ///
  Key
    decomposeMonomialCurve
    (decomposeMonomialCurve,List)
  Headline
    Decomposition for the monomial curve.
  Usage
    decomposeMonomialCurve(A)
  Inputs
    A:List
        containing generators of A
  Outputs
    :List
  Description
   Text
     The list A is expected to contain dehomogenized generators of a semigroup.
     This function transforms A into a homogeneous semigroup containing
     powers of the variables. The corresponding monomial algebra
     is decomposed as a direct sum of ideals in its Noether normalization.

     Here we compute the decomposition for a curve parametrized by the monomials t^a with a \in A
     and B given by the first and the last element of A.

   Example
     A = {1,3,4};
     decomposeMonomialCurve A
   Text

   Example
     for d from 4 to 10 do (A = {1,d-1,d};print(A,decomposeMonomialCurve A));
///



doc ///
  Key
    decomposeMonomialAlgebra
    (decomposeMonomialAlgebra,List)
  Headline
    Decomposition for the monomial curve.
  Usage
    decomposeMonomialCurve(L)
  Inputs
    L:List
        containing generators of A
  Outputs
    :List
  Description
   Text
     The list A contains dehomogenized generators of a semigroup.
     This function transforms A into a homogeneous semigroup containing
     powers of the variables. The corresponding monomial algebra
     is decomposed as a direct sum of ideals in its Noether normalization.
     
   Example
      A = {{1,2},{3,0},{0,4},{0,5}}
      adjoinPurePowers homogenizeSemigroup A
      decomposeMonomialAlgebra (A)
///


doc ///
  Key
    "Curve Example 1"
  Description
   Text
   
    Consider
   
   Example
     A = {1,3,4};
     decomposeMonomialCurve A
///




{*
uninstallPackage("MonomialAlgebras")
installPackage("MonomialAlgebras",RerunExamples=>true);
installPackage("MonomialAlgebras");
*}
