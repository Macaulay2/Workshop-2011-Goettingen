newPackage("Tropical",
     Headline => "A package for tropical geometry",
     Version => "0.1",
     Date => "February 28, 2011",
     Authors => {
	  {Name => "Josephine Yu",
	   HomePage => "http://people.math.gatech.edu/~jyu67",
	   Email => "josephine.yu@math.gatech.edu"}},
      DebuggingMode => true
      )
 
export {
     --objects
      TropicalVariety,
      --methods
      tropicalVariety,
      tropicalMap
      --options
      }
 
needsPackage "gfanInterface2"
-- needsPackage "Polyhedra"
-- needsPackage "Polymake"

-----------------------------------------------
-- OBJECTS
-----------------------------------------------

TropicalVariety = new Type of PolymakeObject;

-----------------------------------------------
-- CONSTRUCTOR
-----------------------------------------------

tropicalVariety = method( Options => {
	"stable" => false, 
	"symmetry" => null, 
	"disableSymmetryTest" => false})
tropicalVariety List := opts -> L -> (
  --   if(opts#"symmetry" === null) then (
    -- 	  gfanTropicalTraverse(gfanTropicalStartingCone(L,"stable" => opts#"stable"), "stable" => opts#"stable")     
--	  ) else (
	  gfanTropicalTraverse(gfanTropicalStartingCone(L,"stable" => opts#"stable"), opts)     
--	  )
     )
tropicalVariety Ideal := opts -> I -> (
     tropicalVariety(I_*, opts)
     )

-----------------------------------------------
-- FUNCTIONS
-----------------------------------------------


----------------local functions-------------------------------

----------------------------
-- normalize
----------------------------
normalize := A -> (
     A/(a-> (g := gcd a; apply(a,i->i//g))
	  )
     )

----------------------------
-- latticeIndex
----------------------------
-- INPUT: a matrix A
-- OUTPUT: index of the lattice generated by rows on A, inside the integer lattice
-- 	   returns 0 if the index is not finite
latticeIndex := A -> (
     det smithNormalForm(A,ChangeMatrix=>{false,false})
     )

----------------------------
-- extrinsicIndex
----------------------------
-- INPUT: a cone C given by a list of generators (lists)
--     	  and a matrix A respresenting a linear map
-- OUTPUT: extrinsic multiplicity of the image cone
--     	   computed as the index of the image lattice in the integer lattice
--     	   a la Sturmfels--Tevelev
extrinsicIndex := (C,A) -> (
     latticeIndex (matrix C * transpose A) // latticeIndex(matrix(C))	  
     )



---------------exported functions--------------------------------

----------------------------
--- tropicalMap
----------------------------
tropicalMap = method()
tropicalMap (PolymakeObject, Matrix) := (T,A) -> (
     if not(numColumns A == T#"AMBIENT_DIM") then
     	  error "The number of columns of the matrix must equal the ambient dimension of the fan";
     H := {"AMBIENT_DIM" => numRows A};
     lineality := transpose gens gb sub(A*transpose matrix T#"LINEALITY_SPACE", QQ);
     H = H| {"LINEALITY_DIM" => numRows lineality, "LINEALITY_SPACE" => entries lineality, "ORTH_LINEALITY" => entries transpose gens kernel lineality} ;
     imageRays := normalize entries transpose(A*transpose matrix(T#"RAYS")) ;  
     numMaxCones := #T#"MAXIMAL_CONES";  
     imageConeIndices := partition(j -> rank ((matrix apply(T#"MAXIMAL_CONES"#j, i -> imageRays#i))||lineality),0..numMaxCones-1);
     newDim := max keys imageConeIndices;
     goodConeIndices := toList imageConeIndices#(newDim); 
     goodRayIndices := select(#imageRays, i -> not (rank ((matrix{imageRays#i}) || lineality) == numRows lineality));
     oldMultList := T#"MULTIPLICITIES";
     multList := apply(goodConeIndices, i -> (
	 C := T#"MAXIMAL_CONES"#i;
    	 intrinMult := oldMultList#i;
     	 extrinMult := extrinsicIndex(C /(j -> T#"RAYS"#j) | T#"LINEALITY_SPACE", A);
	 intrinMult * extrinMult	 
	       ));
     H = H | {"DIM" => newDim + numRows lineality , "RAYS" => apply(goodRayIndices, i-> imageRays#i), "MAXIMAL_CONES" => apply(goodConeIndices, C -> select(apply(T#"MAXIMAL_CONES"#C, i-> position(goodRayIndices, j -> j == i)), c -> not c === null)), "MULTIPLICITIES" => multList};
     new TropicalVariety from hashTable H
     )

----------------------------
--- tropicalResultant
----------------------------

----------------------------
--- tropicalDiscriminant
----------------------------

tropicalDiscriminant = method()
tropicalDiscriminant Matrix := A -> (
     
     )

----------------------------
--- tropicalChowHypersurface
----------------------------

----------------------------
--- rayShooting
----------------------------



--------------------------------------------------------
-- Documentation
--------------------------------------------------------

beginDocumentation()



end

-------------------------------------------------------------
-------------------------------------------------------------

restart
--loadPackage "gfanInterface"
installPackage ("gfanInterface2", FileName => "/Users/bb/Documents/math/M2codes/Goettingen-2011/gfanInterface2.m2", MakeDocumentation => true)
installPackage ("Polymake", FileName => "/Users/bb/Documents/math/M2codes/Goettingen-2011/Polymake.m2", MakeDocumentation => true)

loadPackage ("gfanInterface2", FileName => "/Users/bb/Documents/math/M2codes/Goettingen-2011/gfanInterface2.m2")
loadPackage ("Tropical", FileName => "/Users/bb/Documents/math/M2codes/Goettingen-2011/Tropical.m2", Reload => true)

needsPackage("Tropical", FileName => "/Users/bb/Documents/math/M2codes/Goettingen-2011/Tropical.m2")

viewHelp "gfanInterface2"
viewHelp "Polymake"



P = gfanTropicalStartingCone {x+y+z}
F = gfanTropicalTraverse P
F#D

QQ[z,h,x,y, MonomialOrder => Eliminate 2 ]
I = ideal{1+x+y, x^2-x+y^3-z^4}
J = homogenize(I,h)
T = tropicalVariety J
toPolymakeFormat T
A = matrix{{1, 0, 0, 0}, {0, 1, 0,0 }}
tropicalMap(T,A)
eliminate({z,h},J)
gens J

QQ[x,y,z,w,h]
I = ideal{x+y+z, y^2+2*z^2+3*w^2}
J = homogenize(I,h)
gfanTropicalStartingCone( I_*, "stable" => true)
gfanTropicalStartingCone( I_*)
T = tropicalVariety J
A = matrix{{1, 0, 0, -1, 0},{1,2,3,0,0},{0,2,3,4,5}}
tropicalMap(T,A)

I = ideal{x+y+z, y^2+2*z^2+3*w^2+1}
J = homogenize(I,h)
T = tropicalVariety J
A = matrix{{0, -1, 0, 1, 0}, {0, 1, 0, 0, -1}, {0, 0, 1, 0, -1}}

A = matrix{{0, -1, 0, 1, 0}, {0, 1, 0, 0, -1}, {0, 0, 1, 0, -1},{0,0,0,1,-1}}
B = matrix{{1,1,1,1},{0,1,1,0},{0,0,-1,1},{0,0,0,2}}
hermite B
smithNormalForm B
gens (ZZ^4/image(B))

tropicalMap(T,A)
T
A = matrix{{1,2,3},{1,34,45},{2213,1123,6543},{0,0,0}}
rank A

toPolymakeFormat(T)
viewHelp toPolymakeFormat
viewHelp SRdeformations

A = matrix{{}}